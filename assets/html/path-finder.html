<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pathfinding Lab – A*, Dijkstra, BFS (Single File)</title>
  <meta name="description" content="Interaktives Visualisierungstool für Pfadfindungs‑Algorithmen (A*, Dijkstra, BFS, Greedy). Grid-Editor, Live-Animation, Metriken, Maze-Generator. Eine HTML-Datei, keine Abhängigkeiten." />
  <style>
    :root{
      --bg:#0c1220; --panel:#111a2f; --ink:#e6ecff; --muted:#aeb6d9;
      --acc:#6aa6ff; --acc2:#63e0c9; --warn:#ffb86b; --err:#ff6b6b;
      --grid:#16213a; --grid2:#0e1730; --wall:#2a3458; --start:#60d394; --goal:#ff6b6b;
      --shadow:0 12px 30px rgba(0,0,0,.35);
      --r:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 600px at 60% 120%, #0b1327 0%, var(--bg) 70%, var(--bg) 100%);color:var(--ink);font:15px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial}
    a{color:inherit}

    header{position:sticky;top:0;z-index:10;backdrop-filter:blur(10px);background:color-mix(in oklab,var(--panel) 70%, transparent);border-bottom:1px solid color-mix(in oklab,var(--ink) 10%, transparent)}
    .nav{max-width:1200px;margin:0 auto;padding:.7rem 1rem;display:flex;gap:.8rem;align-items:center;justify-content:space-between}
    .brand{display:flex;gap:.6rem;align-items:center;font-weight:700}
    .brand svg{width:26px;height:26px}

    .wrap{max-width:1200px;margin:0 auto;padding:1rem}

    .panel{background:var(--panel);border:1px solid color-mix(in oklab,var(--ink) 10%, transparent);border-radius:var(--r);box-shadow:var(--shadow)}

    .toolbar{display:grid;grid-template-columns:1fr auto;gap:.8rem;padding:.8rem}
    .controls{display:flex;flex-wrap:wrap;gap:.6rem;align-items:center}
    .group{display:flex;gap:.4rem;align-items:center;background:#0f1830;border:1px solid #1b2747;padding:.4rem .5rem;border-radius:999px}
    label{opacity:.9}
    select,button,input[type="number"],input[type="range"]{appearance:none;background:#0e1730;border:1px solid #243055;color:var(--ink);padding:.45rem .7rem;border-radius:999px}
    select:focus,button:focus,input:focus{outline:2px solid color-mix(in oklab,var(--acc) 45%, transparent);outline-offset:2px}
    button{cursor:pointer}
    .primary{background:linear-gradient(180deg, color-mix(in oklab,var(--acc) 25%, transparent), color-mix(in oklab,var(--acc2) 20%, transparent));border-color:color-mix(in oklab,var(--acc) 50%, transparent)}
    .danger{background:linear-gradient(180deg, color-mix(in oklab,var(--err) 20%, transparent), color-mix(in oklab,#000 5%, transparent));border-color:color-mix(in oklab,var(--err) 40%, transparent)}

    .gridWrap{display:grid;grid-template-columns:1fr 320px;gap:1rem;margin-top:1rem}
    canvas{width:100%;height:auto;background:linear-gradient(180deg,var(--grid),var(--grid2));border-radius:var(--r);border:1px solid #1a2544;box-shadow:var(--shadow);touch-action:none}

    .side{display:grid;align-content:start;gap:.8rem;padding:1rem}
    .stat{display:flex;justify-content:space-between;gap:1rem;background:#0e1730;border:1px solid #1b2747;padding:.6rem .7rem;border-radius:10px}
    .legend{display:grid;grid-template-columns:auto 1fr;gap:.4rem 1rem}
    .dot{width:14px;height:14px;border-radius:3px}
    .lg-wall{background:var(--wall)}
    .lg-visit{background:color-mix(in oklab,var(--acc) 35%, transparent)}
    .lg-open{background:color-mix(in oklab,var(--acc2) 35%, transparent)}
    .lg-path{background:linear-gradient(90deg,var(--acc),var(--acc2))}
    .lg-start{background:var(--start)}
    .lg-goal{background:var(--goal)}

    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;background:#0e1730;border:1px solid #1b2747;padding:.15rem .35rem;border-radius:6px}

    details{background:#0f1830;border:1px solid #1b2747;padding:.6rem .8rem;border-radius:10px}
    summary{cursor:pointer;opacity:.95}

    footer{padding:2rem 1rem;text-align:center;color:var(--muted)}

    @media(max-width:980px){
      .gridWrap{grid-template-columns:1fr}
      .side{grid-row:1}
    }
  </style>
</head>
<body>
  <header>
    <div class="nav wrap">
      <div class="brand" aria-label="Pathfinding Lab">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" aria-hidden="true"><path d="M3 3h6v6H3zM15 3h6v6h-6zM3 15h6v6H3zM15 15h6v6h-6z"/><path d="M6 6l12 12M6 18 18 6"/></svg>
        <span>Pathfinding Lab</span>
      </div>
      <div class="actions">
        <button class="primary" id="runBtn" title="Algorithmus starten (Leertaste)">Start</button>
        <button id="pauseBtn" title="Pause/Weiter (P)">Pause</button>
        <button id="stepBtn" title="Einzelschritt (S)">Schritt</button>
        <button class="danger" id="resetBtn" title="Zurücksetzen (R)">Reset</button>
      </div>
    </div>
  </header>

  <div class="wrap panel toolbar" role="region" aria-label="Werkzeugleiste">
    <div class="controls">
      <div class="group" title="Algorithmus">
        <label for="algo">Algo</label>
        <select id="algo">
          <option value="astar">A*</option>
          <option value="dijkstra">Dijkstra</option>
        </select>
      </div>
      <div class="group" title="Heuristik (A*, Greedy)">
        <label for="heur">Heur</label>
        <select id="heur">
          <option value="manhattan">Manhattan</option>
          <option value="euclid">Euklidisch</option>
          <option value="cheb">Chebyshev</option>
        </select>
      </div>
      <div class="group" title="Geschwindigkeit">
        <label for="speed">Speed</label>
        <input id="speed" type="range" min="1" max="120" value="60" />
      </div>
      <div class="group" title="Gridgröße">
        <label for="size">Grid</label>
        <select id="size">
          <option>20x12</option>
          <option selected>28x16</option>
          <option>36x20</option>
          <option>48x28</option>
        </select>
      </div>
      <div class="group" title="Maus-Werkzeug">
        <label for="tool">Tool</label>
        <select id="tool">
          <option value="wall" selected>Wand</option>
          <option value="weight">Gewicht</option>
          <option value="start">Start</option>
          <option value="goal">Ziel</option>
          <option value="erase">Radierer</option>
        </select>
      </div>
      <button id="mazeBtn" title="Rekursives Division-Maze">Maze</button>
      <button id="shareBtn" title="Zustand teilen (URL)">Share</button>
      <button id="pngBtn" title="Canvas als Bild speichern">PNG</button>
    </div>
  </div>

  <div class="wrap gridWrap">
    <canvas id="c" width="840" height="480" aria-label="Grid Canvas" role="img"></canvas>
    <aside class="panel side" aria-label="Seitenleiste">
      <h3>Legende</h3>
      <div class="legend">
        <div class="dot lg-start"></div><span>Start</span>
        <div class="dot lg-goal"></div><span>Ziel</span>
        <div class="dot lg-wall"></div><span>Wand</span>
        <div class="dot lg-open"></div><span>Frontier/Offen</span>
        <div class="dot lg-visit"></div><span>Besucht</span>
        <div class="dot lg-path"></div><span>Kürzester Pfad</span>
      </div>

      <h3>Statistiken</h3>
      <div class="stat"><span>Knoten besucht</span><strong id="visits">0</strong></div>
      <div class="stat"><span>Pfadlänge</span><strong id="pathlen">0</strong></div>
      <div class="stat"><span>Laufzeit</span><strong id="ms">0 ms</strong></div>
    </aside>
  </div>


  <script>
  const $ = sel => document.querySelector(sel);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const now = () => performance.now();

  const canvas = $('#c');
  const ctx = canvas.getContext('2d');
  let cols = 28, rows = 16; // default
  let cell = 30; // px
  let offsetX = 0.5, offsetY = 0.5; // crisp lines

  let grid = []; 
  let start = {x:2,y:Math.floor(rows/2)};
  let goal  = {x:cols-3,y:Math.floor(rows/2)};

  let running = false, paused=false, stepMode=false;
  let speed = 60; 
  let visits = 0, pathLen = 0, runMs = 0;

  let openSet = new Set();
  let visitedSet = new Set();
  let pathSet = new Set();

  const Tool = { WALL:'wall', WEIGHT:'weight', START:'start', GOAL:'goal', ERASE:'erase' };
  let tool = Tool.WALL;

  // algo + heuristik
  let algo = 'astar';
  let heur = 'manhattan';

  function makeGrid(){
    grid = Array.from({length:rows}, ()=> Array.from({length:cols}, ()=>({wall:false,w:1})) );
  }

  function resizeToSelection(){
    const val = $('#size').value; // e.g. "28x16"
    const [c,r] = val.split('x').map(Number);
    cols = c; rows = r;
    cell = Math.floor( Math.min( Math.max(24, (840/cols)), 40) );
    canvas.width = cols*cell; canvas.height = rows*cell;
    start = {x:2,y:Math.floor(rows/2)};
    goal  = {x:cols-3,y:Math.floor(rows/2)};
    makeGrid();
    draw();
  }

  // ===== Drawing =====
  function drawGrid(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background cells
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const g = grid[y][x];
        ctx.fillStyle = g.wall ? getWallColor(x,y) : getCellColor(x,y,g.w);
        ctx.fillRect(x*cell, y*cell, cell, cell);
      }
    }
    // grid lines (soft)
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let x=0;x<=cols;x++){ ctx.moveTo(x*cell+offsetX,0); ctx.lineTo(x*cell+offsetX,rows*cell); }
    for(let y=0;y<=rows;y++){ ctx.moveTo(0,y*cell+offsetY); ctx.lineTo(cols*cell,y*cell+offsetY); }
    ctx.stroke();
  }

  function getCellColor(x,y,w){
    const key = `${x},${y}`;
    if(pathSet.has(key)) return grad( ["#6aa6ff","#63e0c9"], x/cols );
    if(openSet.has(key)) return 'rgba(114, 230, 200, .22)';
    if(visitedSet.has(key)) return 'rgba(106, 166, 255, .18)';
    // weight tint
    const base = x%2===y%2 ? 'rgba(22, 33, 58, 1)' : 'rgba(14, 23, 48, 1)';
    if(w>1){
      const a = clamp((w-1)/8, 0, .5);
      return `color-mix(in oklab, ${base} ${(1-a)*100}%, #ffb86b ${a*100}%)`;
    }
    return base;
  }
  function getWallColor(){ return '#2a3458'; }
  function grad(colors, t){
    // simple two-color mix
    const [a,b] = colors; t = clamp(t,0,1);
    // fallback linear mix using canvas
    const g = ctx.createLinearGradient(0,0,cell,0);
    g.addColorStop(0,a); g.addColorStop(1,b);
    return g;
  }

  function drawSpecial(){
    // start
    drawCell(start.x,start.y, '#60d394');
    // goal
    drawCell(goal.x,goal.y, '#ff6b6b');
  }
  function drawCell(x,y, color){
    ctx.save();
    ctx.fillStyle = color;
    ctx.fillRect(x*cell+2, y*cell+2, cell-4, cell-4);
    ctx.restore();
  }

  function draw(){
    drawGrid();
    drawSpecial();
  }

  // ===== Interaction =====
  let drawing=false; let lastXY=null;
  canvas.addEventListener('pointerdown', e=>{ drawing=true; handleDraw(e); });
  canvas.addEventListener('pointermove', e=>{ if(drawing) handleDraw(e); });
  window.addEventListener('pointerup', ()=> drawing=false);

  function toCell(e){
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX-rect.left) / (rect.width/canvas.width));
    const y = Math.floor((e.clientY-rect.top)  / (rect.height/canvas.height));
    return {x: clamp(x,0,cols-1), y: clamp(y,0,rows-1)};
  }

  function handleDraw(e){
    const {x,y} = toCell(e);
    const key = `${x},${y}`;
    if(lastXY && lastXY.x===x && lastXY.y===y) return;
    lastXY = {x,y};

    if(tool===Tool.START){ start = {x,y}; draw(); return; }
    if(tool===Tool.GOAL){ goal = {x,y}; draw(); return; }
    const g = grid[y][x];
    if(tool===Tool.ERASE){ g.wall=false; g.w=1; draw(); return; }
    if(tool===Tool.WEIGHT){
      const delta = e.shiftKey ? +1 : e.altKey ? -1 : +1;
      g.w = clamp(g.w + delta, 1, 9); g.wall=false; draw(); return;
    }
    if(tool===Tool.WALL){ g.wall = !g.wall; draw(); return; }
  }

  // ===== Algorithms =====
  function h(a,b){
    const dx = Math.abs(a.x-b.x), dy = Math.abs(a.y-b.y);
    switch(heur){
      case 'euclid': return Math.hypot(dx,dy);
      case 'cheb': return Math.max(dx,dy);
      default: return dx+dy; // manhattan
    }
  }

  function* neighbors(x,y){
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]]; // 4-neigh
    for(const [dx,dy] of dirs){
      const nx=x+dx, ny=y+dy;
      if(nx>=0&&ny>=0&&nx<cols&&ny<rows && !grid[ny][nx].wall){
        yield {x:nx,y:ny,w:grid[ny][nx].w};
      }
    }
  }

  function key(x,y){return `${x},${y}`}

  function reconstruct(prev){
    pathSet.clear();
    let cur = key(goal.x,goal.y);
    let len = 0;
    while(prev.has(cur)){
      pathSet.add(cur);
      cur = prev.get(cur);
      len++;
    }
    pathLen = len;
  }

  function* algoBFS(){
    const q = [start];
    const prev = new Map();
    const seen = new Set([key(start.x,start.y)]);
    while(q.length){
      const cur = q.shift();
      visitedSet.add(key(cur.x,cur.y)); visits++;
      if(cur.x===goal.x && cur.y===goal.y){ reconstruct(prev); return; }
      for(const nb of neighbors(cur.x,cur.y)){
        const k = key(nb.x,nb.y);
        if(!seen.has(k)){
          seen.add(k); prev.set(k, key(cur.x,cur.y)); q.push(nb);
          openSet.add(k);
        }
      }
      yield;
    }
  }

  function* algoDijkstra(){
    const dist = new Map([[key(start.x,start.y),0]]);
    const prev = new Map();
    const pq = [{...start, d:0}];
    const inq = new Map([[key(start.x,start.y),0]]);
    function pop(){
      // small PQ (array) – ok for demo size
      let mi=0; for(let i=1;i<pq.length;i++) if(pq[i].d<pq[mi].d) mi=i;
      return pq.splice(mi,1)[0];
    }
    while(pq.length){
      const cur = pop(); inq.delete(key(cur.x,cur.y));
      visitedSet.add(key(cur.x,cur.y)); visits++;
      if(cur.x===goal.x && cur.y===goal.y){ reconstruct(prev); return; }
      for(const nb of neighbors(cur.x,cur.y)){
        const k=key(nb.x,nb.y); const nd = (dist.get(key(cur.x,cur.y))??Infinity) + nb.w;
        if(nd < (dist.get(k)??Infinity)){
          dist.set(k, nd); prev.set(k, key(cur.x,cur.y));
          const obj = {...nb, d: nd};
          if(inq.has(k)) pq[inq.get(k)] = obj; else { inq.set(k,pq.length); pq.push(obj); }
          openSet.add(k);
        }
      }
      yield;
    }
  }

  function* algoGreedy(){
    const prev = new Map();
    const pq = [{...start, f: h(start,goal)}];
    function pop(){ let mi=0; for(let i=1;i<pq.length;i++) if(pq[i].f<pq[mi].f) mi=i; return pq.splice(mi,1)[0]; }
    const seen = new Set([key(start.x,start.y)]);
    while(pq.length){
      const cur = pop(); visitedSet.add(key(cur.x,cur.y)); visits++;
      if(cur.x===goal.x && cur.y===goal.y){ reconstruct(prev); return; }
      for(const nb of neighbors(cur.x,cur.y)){
        const k = key(nb.x,nb.y);
        if(!seen.has(k)){
          seen.add(k); prev.set(k, key(cur.x,cur.y)); pq.push({...nb, f: h(nb,goal)}); openSet.add(k);
        }
      }
      yield;
    }
  }

  function* algoAStar(){
    const gScore = new Map([[key(start.x,start.y),0]]);
    const fScore = new Map([[key(start.x,start.y), h(start,goal)]]);
    const prev = new Map();
    const pq = [{...start, f: fScore.get(key(start.x,start.y))}];
    function pop(){ let mi=0; for(let i=1;i<pq.length;i++) if(pq[i].f<pq[mi].f) mi=i; return pq.splice(mi,1)[0]; }
    const inOpen = new Set([key(start.x,start.y)]);

    while(pq.length){
      const cur = pop(); inOpen.delete(key(cur.x,cur.y));
      visitedSet.add(key(cur.x,cur.y)); visits++;
      if(cur.x===goal.x && cur.y===goal.y){ reconstruct(prev); return; }
      for(const nb of neighbors(cur.x,cur.y)){
        const k = key(nb.x,nb.y);
        const tentative = (gScore.get(key(cur.x,cur.y))??Infinity) + nb.w;
        if(tentative < (gScore.get(k)??Infinity)){
          gScore.set(k, tentative);
          const f = tentative + h(nb,goal);
          fScore.set(k, f); prev.set(k, key(cur.x,cur.y));
          if(!inOpen.has(k)) { pq.push({...nb, f}); inOpen.add(k); openSet.add(k); }
        }
      }
      yield;
    }
  }

  function selectAlgo(){
    switch(algo){
      case 'bfs': return algoBFS();
      case 'dijkstra': return algoDijkstra();
      case 'greedy': return algoGreedy();
      default: return algoAStar();
    }
  }

  // ===== Animation Loop =====
  let gen = null; let lastTick = 0;
  function resetStats(){ visits=0; pathLen=0; runMs=0; openSet.clear(); visitedSet.clear(); pathSet.clear(); updateStats(); }
  function updateStats(){ $('#visits').textContent = visits; $('#pathlen').textContent = pathLen; $('#ms').textContent = `${Math.round(runMs)} ms`; }

  function tick(ts){
    if(!running) return;
    if(paused){ requestAnimationFrame(tick); return; }
    const t0 = now();
    const stepsPerFrame = Math.ceil(speed/20); // 1..6+
    for(let i=0;i<stepsPerFrame;i++){
      const {done} = gen.next();
      if(done){ running=false; break; }
      if(stepMode) { paused=true; stepMode=false; break; }
    }
    runMs += (now()-t0);
    draw(); updateStats();
    requestAnimationFrame(tick);
  }

  function startRun(){ resetStats(); gen = selectAlgo(); running=true; paused=false; stepMode=false; requestAnimationFrame(tick); }
  function pauseRun(){ paused = !paused; }
  function stepOnce(){ if(!running){ gen = selectAlgo(); running=true; paused=false; } stepMode=true; paused=false; requestAnimationFrame(tick); }
  function resetAll(){ running=false; paused=false; stepMode=false; resetStats(); draw(); }

  // ===== Maze (Recursive Division) =====
  function maze(){
    // clear
    for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){ grid[y][x].wall=false; grid[y][x].w=1; }
    // add borders
    for(let x=0;x<cols;x++){ grid[0][x].wall=true; grid[rows-1][x].wall=true; }
    for(let y=0;y<rows;y++){ grid[y][0].wall=true; grid[y][cols-1].wall=true; }

    function divide(x,y,w,h,orientation){
      if(w<3 || h<3) return;
      const horizontal = orientation==='H';
      const wx = x + (horizontal ? 0 : Math.floor(Math.random()*(w-2))); // wall start
      const wy = y + (horizontal ? Math.floor(Math.random()*(h-2)) : 0);
      const length = horizontal ? w : h;
      const hole = (horizontal ? x : y) + Math.floor(Math.random()* (length-2)) + 1;
      for(let i=0;i<length;i++){
        const px = horizontal ? x+i : wx;
        const py = horizontal ? wy : y+i;
        if((horizontal ? px : py) === hole) continue;
        grid[py][px].wall = true;
      }
      const [nx,ny,nw,nh] = horizontal ? [x,y, w, wy-y] : [x,y, wx-x, h];
      const [mx,my,mw,mh] = horizontal ? [x,wy+1, w, y+h-(wy+1)] : [wx+1,y, x+w-(wx+1), h];
      divide(nx,ny,nw,nh, chooseOrientation(nw,nh));
      divide(mx,my,mw,mh, chooseOrientation(mw,mh));
    }
    function chooseOrientation(w,h){ if(w<h) return 'H'; if(h<w) return 'V'; return Math.random()<.5? 'H':'V'; }
    divide(1,1, cols-2, rows-2, chooseOrientation(cols-2, rows-2));
    draw();
  }

  // ===== Export / Share =====
  function toState(){
    return {
      cols, rows, start, goal,
      cells: grid.flat().map(c=> c.wall? '#' : c.w>1 ? c.w : '.')
    };
  }
  function fromState(s){
    cols=s.cols; rows=s.rows; start=s.start; goal=s.goal;
    canvas.width = cols*cell; canvas.height = rows*cell;
    grid = []; let i=0; for(let y=0;y<rows;y++){ const row=[]; for(let x=0;x<cols;x++){ const t=s.cells[i++]; row.push({wall:t==='#', w: t==='.'?1:Number(t)||1}); } grid.push(row); }
    draw();
  }
  function share(){
    const s = toState();
    const payload = btoa(unescape(encodeURIComponent(JSON.stringify(s))));
    const url = location.origin + location.pathname + '#'+payload;
    navigator.clipboard?.writeText(url);
    alert('Link in Zwischenablage!');
  }
  function loadFromHash(){
    if(location.hash.length>1){
      try{
        const s = JSON.parse(decodeURIComponent(escape(atob(location.hash.slice(1)))));
        fromState(s);
      }catch(e){ console.warn('Share-Parse',e); }
    }
  }
  function savePNG(){
    const a = document.createElement('a'); a.download = 'pathfinding.png'; a.href = canvas.toDataURL('image/png'); a.click();
  }

  // ===== Wiring =====
  $('#algo').addEventListener('change', e=>{ algo=e.target.value; });
  $('#heur').addEventListener('change', e=>{ heur=e.target.value; });
  $('#speed').addEventListener('input', e=>{ speed=Number(e.target.value); });
  $('#size').addEventListener('change', ()=>{ resizeToSelection(); });
  $('#tool').addEventListener('change', e=>{ tool=e.target.value; });

  $('#runBtn').addEventListener('click', startRun);
  $('#pauseBtn').addEventListener('click', pauseRun);
  $('#stepBtn').addEventListener('click', stepOnce);
  $('#resetBtn').addEventListener('click', resetAll);
  $('#mazeBtn').addEventListener('click', maze);
  $('#shareBtn').addEventListener('click', share);
  $('#pngBtn').addEventListener('click', savePNG);

  window.addEventListener('keydown', e=>{
    if(e.code==='Space'){ e.preventDefault(); startRun(); }
    else if(e.key.toLowerCase()==='p'){ pauseRun(); }
    else if(e.key.toLowerCase()==='s'){ stepOnce(); }
    else if(e.key.toLowerCase()==='r'){ resetAll(); }
  });

  // ===== Startup =====
  function boot(){
    resizeToSelection();
    makeGrid();
    loadFromHash();
    draw();
  }
  boot();

  // ===== Progressive polish: animate skill bars when visible (demo) =====
  // (Not used here; placeholder for intersection observers in bigger demos)
  </script>
</body>
</html>
